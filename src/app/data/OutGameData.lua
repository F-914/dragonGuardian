---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Zoybzo.
--- DateTime: 2022-07-05 16:18
---
local OutGameData = {}
--local
local ConstDef = require("app.def.ConstDef")
local EventDef = require("app.def.EventDef")
local EventManager = require("app.manager.EventManager")
local UserInfo = require("app.data.UserInfo")
local Shop = require("app.data.Shop")
local TestDataFactory = require("app.test.TestDataFactory")


local Factory = require("app.utils.Factory")
local TowerDef = require("app.def.TowerDef")
local Log = require("app.utils.Log")

--网络部分
local OutGameMsgController = require("app.network.OutGameMsgController")
local MsgDef = require("app.def.MsgDef")
local TableUtil = require("app.utils.TableUtil")

--
local _userInfo
local _coinShop
local _diamondShop
local _treasureBoxRewardWinningRate
local _isAlive
local _loginName
local _scene
--function OutGameData:init()
--    --暂时先用这里的假数据，后面改成发送消息的方式初始化数据
--    self:initUserInfo()
--    self:initCoinShop()
--    self:initDiamondShop()
--    self:initTreasureBoxRewardWinningRate()
--end
---初始化outGameData信息至少需要一个loginName，再outGameScene处我随便写了个
function OutGameData:init(loginName, scene)
    OutGameMsgController:init("127.0.0.1", 33333, 2)
    OutGameMsgController:connect()
    self:register()
    _loginName = loginName
    _scene = scene
    self:initTreasureBoxRewardWinningRate()
end

-- 调用 OutGameData:getTreasureBoxRewardWinningRate()[ConstDef.TREASUREBOX_RARITY.R][ConstDef.TREASUREBOX_REWARD.R]
function OutGameData:getTreasureBoxRewardWinningRate()
    if _treasureBoxRewardWinningRate == nil then
        self:initTreasureBoxRewardWinningRate()
    end
    return _treasureBoxRewardWinningRate
end

function OutGameData:initTreasureBoxRewardWinningRate()
    -- TODO 感觉这个数据可能很少会发生变动，但是也不排除后续更新的可能
    _treasureBoxRewardWinningRate = {
        {
            -- 普通宝箱的没有找到
            { 0, 0 },
            { 0, 0 },
            { 0, 0 },
            { 0, 0 },
            { 0, 0 },

        },
        {
            { 130, 130 },
            { 40, 40 },
            { 7, 7 },
            { 0, 1 },
            { 1230, 1230 }
        },
        {
            { 139, 139 },
            { 36, 6 },
            { 7, 7 },
            { 0, 1 },
            { 1280, 1280 }
        },
        {
            { 187, 187 },
            { 51, 51 },
            { 21, 21 },
            { 1, 1 },
            { 3040, 3040 }
        }
    }
end

---测试的时候就用下面这三个函数
--function OutGameData:initDiamondShop()
--    _diamondShop = TestDataFactory:getTestDiamondShop()
--end
--
--function OutGameData:initCoinShop()
--    _coinShop = TestDataFactory:getTestCoinShop()
--end
--
--function OutGameData:initUserInfo()
--    _userInfo = UserInfo:getInstance()
--end

-- function OutGameData:register()

-- end

---测试的时候就用下面这三个函数
--function OutGameData:initDiamondShop()
--    _diamondShop = TestDataFactory:getTestDiamondShop()
--end
--
--function OutGameData:initCoinShop()
--    _coinShop = TestDataFactory:getTestCoinShop()
--end
--
--function OutGameData:initUserInfo()
--    _userInfo = UserInfo:getInstance()
--end

function OutGameData:register()


    ---这一部分是同步和初始化函数
    OutGameMsgController:registerListener(MsgDef.ACKTYPE.LOBBY.USERINFO_INIT,
        handler(self, self.initUserInfo))
    OutGameMsgController:registerListener(MsgDef.ACKTYPE.LOBBY.DIAMONDSHOP_INIT,
        handler(self, self.initDiamondShop))
    OutGameMsgController:registerListener(MsgDef.ACKTYPE.LOBBY.COINSHOP_INIT,
        handler(self, self.initCoinShop))
    OutGameMsgController:registerListener(MsgDef.ACKTYPE.LOBBY.USERINFO_DS,
        handler(self, self.userInfoDS))
    OutGameMsgController:registerListener(MsgDef.ACKTYPE.LOBBY.DIAMONDSHOP_DS,
        handler(self, self.diamondShopDS))
    OutGameMsgController:registerListener(MsgDef.ACKTYPE.LOBBY.COINSHOP_DS,
        handler(self, self.coinShopDS))

    ---这一部分是代表事件的函数
    OutGameMsgController:registerListener(MsgDef.ACKTYPE.LOBBY.CARD_COLLECT,
        handler(self, self.addCard))
    OutGameMsgController:registerListener(MsgDef.ACKTYPE.LOBBY.CARD_ATTRIBUTE_CHANGE,
        handler(self, self.changeCardAttribute))
    OutGameMsgController:registerListener(MsgDef.ACKTYPE.LOBBY.ASSERT_CHANGE,
        handler(self, self.assertChange))
    OutGameMsgController:registerListener(MsgDef.ACKTYPE.LOBBY.RECEIVE_REWARD,
        handler(self, self.receiveReward))
    OutGameMsgController:registerListener(MsgDef.ACKTYPE.LOBBY.PURCHASE_COMMODITY,
        handler(self, self.purchaseCommodity))
end

--[[--
    @description 本地同步来自服务器userinfo的数据
    @param msg type:table, 由服务器发送的消息
]]
function OutGameData:userInfoDS(msg)
    _userInfo = TableUtil:toUserInfo(msg.userInfo)
end

--[[--
    @description 本地同步来自服务器userinfo的数据
    每一次同步都会弃用原来的数据,会造成资源浪费
    @param msg type:table, 由服务器发送的消息
]]
function OutGameData:coinShopDS(msg)
    _coinShop = TableUtil:toShop(msg.coinShop)
end

--[[--
    @description 本地同步来自服务器userinfo的数据
    每一次同步都会弃用原来的数据,会造成资源浪费
    @param msg type:table, 由服务器发送的消息
]]
function OutGameData:diamondShopDS(msg)
    _diamondShop = TableUtil:toShop(msg.diamondShop)
end

--[[--

]]
local count = 1
function OutGameData:update(dt)
    ---在这里,进行计时，每隔一段时间进行发送消息进行数据同步
    ---同时隔一段事件发送心跳消息，确认在线
end

local initCount = 1
function OutGameData:initDiamondShop(msg)
    _diamondShop = TableUtil:toShop(msg.diamondShop)
    if initCount == 3 then
        _scene:eventTriggerLoadView()
    else
        initCount = initCount + 1
    end
end

function OutGameData:initCoinShop(msg)
    _coinShop = TableUtil:toShop(msg.coinShop)
    if initCount == 3 then
        _scene:eventTriggerLoadView()
    else
        initCount = initCount + 1
    end
end

function OutGameData:initUserInfo(msg)
    _userInfo = TableUtil:toUserInfo(msg.userInfo)
    if initCount == 3 then
        _scene:eventTriggerLoadView()
    else
        initCount = initCount + 1
    end
end

function OutGameData:eventTriggerInit()
    local msgUserInfo = TableUtil:encapsulateAsMsg(MsgDef.REQTYPE.LOBBY.USERINFO_INIT, _loginName)
    local msgCoinShop = TableUtil:encapsulateAsMsg(MsgDef.REQTYPE.LOBBY.COINSHOP_INIT, _loginName)
    local msgDiamondShop = TableUtil:encapsulateAsMsg(MsgDef.REQTYPE.LOBBY.DIAMONDSHOP_INIT, _loginName)
    OutGameMsgController:sendMsg(msgUserInfo)
    OutGameMsgController:sendMsg(msgCoinShop)
    OutGameMsgController:sendMsg(msgDiamondShop)
end

--[[--
    @description 接受来自服务器的消息，确定新增的卡片,并将数据同步至本地数据
    这个函数可以一口气增加大量卡片
    但是目前card中尚无卡片数量的属性,所以暂时不写
    @msg, type:table 来自服务器的消息
    @return none
]]
function OutGameData:addCard(msg)
    local msgCards = msg.userInfo.userInfoCardList
    local cardList = _userInfo:getUserInfoCardList()
    for i = 1, #msgCards do
        local cardTable = msgCards[i]
        if cardList[cardTable.cardId] then
            cardList[cardTable.cardId]:addCardAmount(cardTable.cardAmount)
        else
            local srcCard = TableUtil:toCard(cardTable)
            table.insert(cardList, srcCard.cardId_, srcCard)
        end
    end
end

--[[--
    @description 确认来自服务器的消息，将数据同步至本地数据
    这个里面应该保存由表示修改属性后card的对象,用该对象替换当前对象
    一次可以修改多个(但是会导致时间复杂度大幅度上升,因为需要遍历整个
    cardList,不建议,数组类型,内部没有特别的结构,决定了算法的上限),
    这里一共需要修改队伍数据和卡片列表的数据
    这个函数也可以用于增加卡片
    @msg type:table 来自服务器的消息
]]
function OutGameData:changeCardAttribute(msg)
    local msgCards = msg.userInfo.userInfoCardList
    local cardList = _userInfo:getUserInfoCardList()
    for i = 1, #msgCards do
        ---替换的数据
        local srcCard = TableUtil:toCard(msgCards[i])
        if cardList[srcCard.cardId_] then
            table.remove(cardList, srcCard.cardId_)
            table.insert(cardList, srcCard.cardId_, srcCard)
        else
            if srcCard.cardId_ < 1 or srcCard.cardId_ > 20 then
                Log.e("the param cardId is illegal in msg.userInfo.cardList[?]")
            else
                table.insert(cardList, srcCard.cardId_, srcCard)
            end
        end
    end
end

--[[--
    @description 将购买的商品的数据同步至本地
    这是用户购买的卡片的列表

    msg中需要由userInfo属性，userInfo中需要有coinAmount和diamondAmount
    以及cardList属性

    以开宝箱为例， 在用户购买宝箱后，将开出的奖励和金币钻石的变化后的值传给服务器，服务器将数据确认保存后
    再将数据传回本地，确保本地数据和服务器统一
    另一方面，这个函数的运行要再奖励显示界面之前，不能显示奖励之后再传递消息给服务器

    其他同理

    @msg type:table 来自服务器的数据
]]
function OutGameData:purchaseCommodity(msg)
    --将金币变化后的值更新
    _userInfo:setUserInfoCoinAmount(msg.userInfo.userInfoCoinAmount)
    _userInfo:setUserInfoDiamondAmount(msg.userInfo.userInfoDiamondAmount)

    --将卡片数据合并至userInfo中
    local msgCards = msg.userInfo.userInfoCardList
    local cardList = _userInfo:getUserInfoCardList()
    for i = 1, #msgCards do
        local cardTable = msgCards[i]
        if cardList[cardTable.cardId] then
            cardList[cardTable.cardId]:addCardAmount(cardTable.cardAmount)
        else
            local srcCard = TableUtil:toCard(cardTable)
            table.insert(cardList, srcCard.cardId_, srcCard)
        end
    end
end

--[[--
    @description 将金币和钻石的变化后的数据同步至本地
    msg中需要有userInfo属性，userInfo属性中必须有coinAmount和diamondAmount
    @msg type：table 来自服务器的数据
]]
function OutGameData:assertChange(msg)
    _userInfo:setUserInfoCoinAmount(msg.userInfo.coinAmount)
    _userInfo:setUserInfoDiamondAmount(msg.userInfo.diamondAmount)
end

--[[--
    @description:该函数用于修改用户天梯的奖杯数
    该函数同时负责天梯奖励的解锁进度,保证数据同步
    对消息的要求是只需要传回奖杯数就可以,但是再服务器那边也必须同步天梯奖励
]]
function OutGameData:trophyChange(msg)
    local amount = msg.userInfo.userInfoTrophyAmount
    _userInfo:setUserInfoTrophyAmount(amount)
    local ladderList = _userInfo:getUserInfoLadder():getLadderList()
    for i = 1, #ladderList do
        if amount > ladderList[i]:getTrophyCondition() then
            ladderList[i]:setLocked(false)
        end
    end
end

--[[--
    @description:该函数用于领取奖励后同步本地数据
    这个函数和上面的购买商品的函数是几乎一模一样,除了增加了修改天梯数据的部分
]]
function OutGameData:receiveReward(msg)
    print("received")
    _userInfo:setUserInfoCoinAmount(msg.userInfo.userInfoCoinAmount)
    _userInfo:setUserInfoDiamondAmount(msg.userInfo.userInfoDiamondAmount)
    --将卡片数据合并至userInfo中
    local msgCards = msg.userInfo.userInfoCardList
    local cardList = _userInfo:getUserInfoCardList()
    for i = 1, #msgCards do
        local cardTable = msgCards[i]
        if cardList[cardTable.cardId] then
            cardList[cardTable.cardId]:addCardAmount(cardTable.cardAmount)
        else
            local srcCard = TableUtil:toCard(cardTable)
            table.insert(cardList, srcCard.cardId_, srcCard)
        end
    end

    ---由于reward并没有明确的主码,所以用trophyAmount作为主码,将
    ---trophyAmount匹配的对象领取状态修改
    local ladderTable = msg.userInfo.userInfoLadder.ladderList
    local ladderList = _userInfo:getUserInfoLadder():getLadderList()
    for i = 1, #ladderTable do
        for j = 1, #ladderList do
            if ladderList[j].trophyCondition_ ==
                ladderTable[i].trophyCondition then
                ladderList[j]:setReceived(true)
            end
        end
    end
end

--[[--
    @description: 同步队伍数据
    玩家修改队伍信息后同步
]]
function OutGameData:modifyBattleTeam(msg)
    _userInfo:setUserInfoBattleTeam(TableUtil
        :toBattleTeam(msg.userInfo.battleTeam))

end

-- 不太确定函数返回的是引用还是复制的值，所以调用的时候还是先调用这个再用别的
function OutGameData:getUserInfo()
    --if _userInfo == nil then
    --    local msgUserInfo = TableUtil:encapsulateAsMsg(MsgDef.REQTYPE.LOBBY.USERINFO_INIT, _loginName)
    --    OutGameMsgController:sendMsg(msgUserInfo)
    --end
    return _userInfo
end

function OutGameData:getCoinShop()
    --if _coinShop == nil then
    --    local msgCoinShop = TableUtil:encapsulateAsMsg(MsgDef.REQTYPE.LOBBY.COINSHOP_INIT, _loginName)
    --    OutGameMsgController:sendMsg(msgCoinShop)
    --end
    return _coinShop
end

function OutGameData:getDiamondShop()
    --if _diamondShop == nil then
    --    local msgDiamondShop = TableUtil:encapsulateAsMsg(MsgDef.REQTYPE.LOBBY.DIAMONDSHOP_INIT, _loginName)
    --    OutGameMsgController:sendMsg(msgDiamondShop)
    --end
    return _diamondShop
end

--[[--
    @description:这个函数用于随机生成奖励
    @param type:宝箱的类型，
    @return type:array 返回一个array

    之所以只有这么点属性，是因为这些属性足够表示出一个刚从宝箱开出来的卡片，
    同时将这样的消息传递给服务器时，传递的消息也比较少
]]
function OutGameData:openTreasureBox(rewardType)
    --local rewardData = self:getTreasureBoxRewardWinningRate()[rewardType]
    math.randomseed(os.time())
    local res = {}
    local rArray = TableUtil:clone(TowerDef.TOWER_R_IDLIST)
    local srArray = TableUtil:clone(TowerDef.TOWER_SR_IDLIST)
    local ssrArray = TableUtil:clone(TowerDef.TOWER_SSR_IDLIST)
    local urArray = TableUtil:clone(TowerDef.TOWER_UR_IDLIST)
    for i = 1, 8 do
        if i >= 1 and i <= 4 then
            local removeIndex = math.random(1, #rArray)
            res[i] = Factory:createCardObj(rArray[removeIndex], math.random(30, 50))
            table.remove(rArray, removeIndex)
        elseif i >= 5 and i <= 6 then
            local removeIndex = math.random(1, #srArray)
            res[i] = Factory:createCardObj(srArray[removeIndex], math.random(7, 13))
            table.remove(srArray, removeIndex)
        elseif i == 7 then
            local removeIndex = math.random(1, #ssrArray)
            res[i] = Factory:createCardObj(ssrArray[removeIndex], math.random(7, 13))
            table.remove(ssrArray, removeIndex)
        elseif i == 8 then
            local removeIndex = math.random(1, #urArray)
            res[i] = Factory:createCardObj(urArray[removeIndex], math.random(0, 1))
            table.remove(urArray, removeIndex)
        end
    end
    res.coinNum = 2333
    return res
end

return OutGameData
